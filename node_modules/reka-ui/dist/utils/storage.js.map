{"version":3,"file":"storage.js","sources":["../../src/Splitter/utils/storage.ts"],"sourcesContent":["import type { PanelGroupStorage } from '../SplitterGroup.vue'\nimport type { PanelData } from '../SplitterPanel.vue'\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nexport function initializeDefaultStorage(storageObject: PanelGroupStorage) {\n  try {\n    if (typeof localStorage !== 'undefined') {\n      // Bypass this check for future calls\n      storageObject.getItem = (name: string) => {\n        return localStorage.getItem(name)\n      }\n      storageObject.setItem = (name: string, value: string) => {\n        localStorage.setItem(name, value)\n      }\n    }\n    else {\n      throw new TypeError('localStorage not supported in this environment')\n    }\n  }\n  catch (error) {\n    console.error(error)\n\n    storageObject.getItem = () => null\n    storageObject.setItem = () => {}\n  }\n}\n\nexport type PanelConfigurationState = {\n  expandToSizes: {\n    [panelId: string]: number\n  }\n  layout: number[]\n}\n\nexport type SerializedPanelGroupState = {\n  [panelIds: string]: PanelConfigurationState\n}\n\nfunction getPanelGroupKey(autoSaveId: string): string {\n  return `reka:${autoSaveId}`\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels: PanelData[]): string {\n  return panels\n    .map((panel) => {\n      const { constraints, id, idIsFromProps, order } = panel\n      if (idIsFromProps) {\n        return id\n      }\n      else {\n        return order\n          ? `${order}:${JSON.stringify(constraints)}`\n          : JSON.stringify(constraints)\n      }\n    })\n    .sort((a, b) => a.localeCompare(b))\n    .join(',')\n}\n\nfunction loadSerializedPanelGroupState(\n  autoSaveId: string,\n  storage: PanelGroupStorage,\n): SerializedPanelGroupState | null {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId)\n    const serialized = storage.getItem(panelGroupKey)\n    if (serialized) {\n      const parsed = JSON.parse(serialized)\n      if (typeof parsed === 'object' && parsed != null)\n        return parsed as SerializedPanelGroupState\n    }\n  }\n  catch (error) {}\n\n  return null\n}\n\nexport function loadPanelGroupState(\n  autoSaveId: string,\n  panels: PanelData[],\n  storage: PanelGroupStorage,\n): PanelConfigurationState | null {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) ?? {}\n  const panelKey = getPanelKey(panels)\n  return state[panelKey] ?? null\n}\n\nexport function savePanelGroupState(\n  autoSaveId: string,\n  panels: PanelData[],\n  panelSizesBeforeCollapse: Map<string, number>,\n  sizes: number[],\n  storage: PanelGroupStorage,\n): void {\n  const panelGroupKey = getPanelGroupKey(autoSaveId)\n  const panelKey = getPanelKey(panels)\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) ?? {}\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes,\n  }\n\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state))\n  }\n  catch (error) {\n    console.error(error)\n  }\n}\n"],"names":[],"mappings":"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"}