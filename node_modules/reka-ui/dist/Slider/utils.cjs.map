{"version":3,"file":"utils.cjs","sources":["../../src/Slider/utils.ts"],"sourcesContent":["import { clamp, createContext } from '@/shared'\n\nexport interface SliderOrientationPrivateProps {\n  min: number\n  max: number\n  inverted: boolean\n}\n\nexport type SliderOrientationPrivateEmits = {\n  slideEnd: []\n  slideStart: [value: number]\n  slideMove: [value: number]\n  homeKeyDown: [event: KeyboardEvent]\n  endKeyDown: [event: KeyboardEvent]\n  stepKeyDown: [event: KeyboardEvent, direction: number]\n}\n\nexport function getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues]\n  nextValues[atIndex] = nextValue\n  return nextValues.sort((a, b) => a - b)\n}\n\nexport function convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min\n  const percentPerStep = 100 / maxSteps\n  const percentage = percentPerStep * (value - min)\n  return clamp(percentage, 0, 100)\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nexport function getLabel(index: number, totalValues: number) {\n  if (totalValues > 2)\n    return `Value ${index + 1} of ${totalValues}`\n\n  else if (totalValues === 2)\n    return ['Minimum', 'Maximum'][index]\n\n  else\n    return undefined\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nexport function getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1)\n    return 0\n  const distances = values.map(value => Math.abs(value - nextValue))\n  const closestDistance = Math.min(...distances)\n  return distances.indexOf(closestDistance)\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nexport function getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2\n  const halfPercent = 50\n  const offset = linearScale([0, halfPercent], [0, halfWidth])\n  return (halfWidth - offset(left) * direction) * direction\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nexport function getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value)\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nexport function hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values)\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues)\n    return actualMinStepsBetweenValues >= minStepsBetweenValues\n  }\n  return true\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nexport function linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1])\n      return output[0]\n    const ratio = (output[1] - output[0]) / (input[1] - input[0])\n    return output[0] + ratio * (value - input[0])\n  }\n}\n\nexport function getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length\n}\n\nexport function roundValue(value: number, decimalCount: number) {\n  const rounder = 10 ** decimalCount\n  return Math.round(value * rounder) / rounder\n}\n\nexport type Direction = 'ltr' | 'rtl'\n\nexport const PAGE_KEYS = ['PageUp', 'PageDown']\nexport const ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight']\n\ntype SlideDirection = 'from-left' | 'from-right' | 'from-bottom' | 'from-top'\nexport const BACK_KEYS: Record<SlideDirection, string[]> = {\n  'from-left': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-right': ['Home', 'PageDown', 'ArrowDown', 'ArrowRight'],\n  'from-bottom': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-top': ['Home', 'PageDown', 'ArrowUp', 'ArrowLeft'],\n\n}\n\ntype Side = 'top' | 'right' | 'bottom' | 'left'\ninterface SliderOrientation {\n  startEdge: Side\n  endEdge: Side\n  size: 'width' | 'height'\n  direction: number\n}\n\nexport const [injectSliderOrientationContext, provideSliderOrientationContext]\n  = createContext<SliderOrientation>(['SliderVertical', 'SliderHorizontal'])\n"],"names":["clamp","createContext"],"mappings":"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"}