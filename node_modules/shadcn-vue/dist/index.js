#!/usr/bin/env node

// src/commands/init.ts
import { promises as fs7 } from "node:fs";

// src/utils/handle-error.ts
import { consola } from "consola";
function handleError(error) {
  consola.log("this is error: ", error);
  if (typeof error === "string") {
    consola.error(error);
    process.exit(1);
  }
  if (error instanceof Error) {
    consola.error(error.message);
    process.exit(1);
  }
  consola.error("Something went wrong. Please try again.");
  process.exit(1);
}

// src/utils/highlighter.ts
import { colors } from "consola/utils";
var highlighter = {
  error: colors.red,
  warn: colors.yellow,
  info: colors.cyan,
  success: colors.green
};

// src/utils/logger.ts
import consola2 from "consola";
var logger = {
  error(...args) {
    consola2.log(highlighter.error(args.join(" ")));
  },
  warn(...args) {
    consola2.log(highlighter.warn(args.join(" ")));
  },
  info(...args) {
    consola2.log(highlighter.info(args.join(" ")));
  },
  success(...args) {
    consola2.log(highlighter.success(args.join(" ")));
  },
  log(...args) {
    consola2.log(args.join(" "));
  },
  break() {
    consola2.log("");
  }
};

// src/utils/registry/schema.ts
import { z } from "zod";
var registryItemTypeSchema = z.enum([
  "registry:style",
  "registry:lib",
  "registry:example",
  "registry:block",
  "registry:component",
  "registry:ui",
  "registry:hook",
  "registry:theme",
  "registry:page"
]);
var registryItemFileSchema = z.object({
  path: z.string(),
  content: z.string().optional(),
  type: registryItemTypeSchema,
  target: z.string().optional()
});
var registryItemTailwindSchema = z.object({
  config: z.object({
    content: z.array(z.string()).optional(),
    theme: z.record(z.string(), z.any()).optional(),
    plugins: z.array(z.string()).optional()
  }).optional()
});
var registryItemCssVarsSchema = z.object({
  light: z.record(z.string(), z.string()).optional(),
  dark: z.record(z.string(), z.string()).optional()
});
var registryItemSchema = z.object({
  name: z.string(),
  type: registryItemTypeSchema,
  description: z.string().optional(),
  dependencies: z.array(z.string()).optional(),
  devDependencies: z.array(z.string()).optional(),
  registryDependencies: z.array(z.string()).optional(),
  files: z.array(registryItemFileSchema).optional(),
  tailwind: registryItemTailwindSchema.optional(),
  cssVars: registryItemCssVarsSchema.optional(),
  meta: z.record(z.string(), z.any()).optional(),
  docs: z.string().optional()
});
var registryIndexSchema = z.array(
  registryItemSchema.extend({
    files: z.array(z.union([z.string(), registryItemFileSchema])).optional()
  })
);
var stylesSchema = z.array(
  z.object({
    name: z.string(),
    label: z.string()
  })
);
var iconsSchema = z.record(
  z.string(),
  z.record(z.string(), z.string())
);
var registryBaseColorSchema = z.object({
  inlineColors: z.object({
    light: z.record(z.string(), z.string()),
    dark: z.record(z.string(), z.string())
  }),
  cssVars: z.object({
    light: z.record(z.string(), z.string()),
    dark: z.record(z.string(), z.string())
  }),
  inlineColorsTemplate: z.string(),
  cssVarsTemplate: z.string()
});
var registryResolvedItemsTreeSchema = registryItemSchema.pick({
  dependencies: true,
  devDependencies: true,
  files: true,
  tailwind: true,
  cssVars: true,
  docs: true
});

// src/utils/updaters/update-tailwind-config.ts
import { promises as fs } from "node:fs";
import { tmpdir } from "node:os";

// src/utils/spinner.ts
import ora from "ora";
function spinner(text, options) {
  return ora({
    text,
    isSilent: options?.silent
  });
}

// src/utils/updaters/update-tailwind-config.ts
import deepmerge from "deepmerge";
import path from "pathe";
import objectToString from "stringify-object";
import {
  Project,
  QuoteKind,
  ScriptKind,
  SyntaxKind
} from "ts-morph";
async function updateTailwindConfig(tailwindConfig, config, options) {
  if (!tailwindConfig) {
    return;
  }
  options = {
    silent: false,
    ...options
  };
  const tailwindFileRelativePath = path.relative(
    config.resolvedPaths.cwd,
    config.resolvedPaths.tailwindConfig
  );
  const tailwindSpinner = spinner(
    `Updating ${highlighter.info(tailwindFileRelativePath)}`,
    {
      silent: options.silent
    }
  ).start();
  const raw = await fs.readFile(config.resolvedPaths.tailwindConfig, "utf8");
  const output = await transformTailwindConfig(raw, tailwindConfig, config);
  await fs.writeFile(config.resolvedPaths.tailwindConfig, output, "utf8");
  tailwindSpinner?.succeed();
}
async function transformTailwindConfig(input, tailwindConfig, config) {
  const sourceFile = await _createSourceFile(input, config);
  const configObject = sourceFile.getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression).find(
    (node) => node.getProperties().some(
      (property) => property.isKind(SyntaxKind.PropertyAssignment) && property.getName() === "content"
    )
  );
  if (!configObject) {
    return input;
  }
  const quoteChar = _getQuoteChar(configObject);
  addTailwindConfigProperty(
    configObject,
    {
      name: "darkMode",
      value: "class"
    },
    { quoteChar }
  );
  tailwindConfig.plugins?.forEach((plugin) => {
    addTailwindConfigPlugin(configObject, plugin);
  });
  if (tailwindConfig.theme) {
    await addTailwindConfigTheme(configObject, tailwindConfig.theme);
  }
  return sourceFile.getFullText();
}
function addTailwindConfigProperty(configObject, property, {
  quoteChar
}) {
  const existingProperty = configObject.getProperty("darkMode");
  if (!existingProperty) {
    const newProperty = {
      name: property.name,
      initializer: `[${quoteChar}${property.value}${quoteChar}]`
    };
    if (property.name === "darkMode") {
      configObject.insertPropertyAssignment(0, newProperty);
      return configObject;
    }
    configObject.addPropertyAssignment(newProperty);
    return configObject;
  }
  if (existingProperty.isKind(SyntaxKind.PropertyAssignment)) {
    const initializer = existingProperty.getInitializer();
    const newValue = `${quoteChar}${property.value}${quoteChar}`;
    if (initializer?.isKind(SyntaxKind.StringLiteral)) {
      const initializerText = initializer.getText();
      initializer.replaceWithText(`[${initializerText}, ${newValue}]`);
      return configObject;
    }
    if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {
      if (initializer.getElements().map((element) => element.getText()).includes(newValue)) {
        return configObject;
      }
      initializer.addElement(newValue);
    }
    return configObject;
  }
  return configObject;
}
async function addTailwindConfigTheme(configObject, theme) {
  if (!configObject.getProperty("theme")) {
    configObject.addPropertyAssignment({
      name: "theme",
      initializer: "{}"
    });
  }
  nestSpreadProperties(configObject);
  const themeProperty = configObject.getPropertyOrThrow("theme")?.asKindOrThrow(SyntaxKind.PropertyAssignment);
  const themeInitializer = themeProperty.getInitializer();
  if (themeInitializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {
    const themeObjectString = themeInitializer.getText();
    const themeObject = await parseObjectLiteral(themeObjectString);
    const result = deepmerge(themeObject, theme, {
      arrayMerge: (dst, src) => src
    });
    const resultString = objectToString(result).replace(/'\.\.\.(.*)'/g, "...$1").replace(/'"/g, "'").replace(/"'/g, "'").replace(/'\[/g, "[").replace(/\]'/g, "]").replace(/'\\'/g, "'").replace(/\\'/g, "'").replace(/\\''/g, "'").replace(/''/g, "'");
    themeInitializer.replaceWithText(resultString);
  }
  unnestSpreadProperties(configObject);
}
function addTailwindConfigPlugin(configObject, plugin) {
  const existingPlugins = configObject.getProperty("plugins");
  if (!existingPlugins) {
    configObject.addPropertyAssignment({
      name: "plugins",
      initializer: `[${plugin}]`
    });
    return configObject;
  }
  if (existingPlugins.isKind(SyntaxKind.PropertyAssignment)) {
    const initializer = existingPlugins.getInitializer();
    if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {
      if (initializer.getElements().map((element) => {
        return element.getText().replace(/["']/g, "");
      }).includes(plugin.replace(/["']/g, ""))) {
        return configObject;
      }
      initializer.addElement(plugin);
    }
    return configObject;
  }
  return configObject;
}
async function _createSourceFile(input, config) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), "shadcn-"));
  const resolvedPath = config?.resolvedPaths?.tailwindConfig || "tailwind.config.ts";
  const tempFile = path.join(dir, `shadcn-${path.basename(resolvedPath)}`);
  const project = new Project({
    compilerOptions: {}
  });
  const sourceFile = project.createSourceFile(tempFile, input, {
    // Note: .js and .mjs can still be valid for TS projects.
    // We can't infer TypeScript from config.tsx.
    scriptKind: path.extname(resolvedPath) === ".ts" ? ScriptKind.TS : ScriptKind.JS
  });
  return sourceFile;
}
function _getQuoteChar(configObject) {
  return configObject.getFirstDescendantByKind(SyntaxKind.StringLiteral)?.getQuoteKind() === QuoteKind.Single ? "'" : '"';
}
function nestSpreadProperties(obj) {
  const properties = obj.getProperties();
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.isKind(SyntaxKind.SpreadAssignment)) {
      const spreadAssignment = prop.asKindOrThrow(SyntaxKind.SpreadAssignment);
      const spreadText = spreadAssignment.getExpression().getText();
      obj.insertPropertyAssignment(i, {
        // Need to escape the name with " so that deepmerge doesn't mishandle the key
        name: `"___${spreadText.replace(/^\.\.\./, "")}"`,
        initializer: `"...${spreadText.replace(/^\.\.\./, "")}"`
      });
      spreadAssignment.remove();
    } else if (prop.isKind(SyntaxKind.PropertyAssignment)) {
      const propAssignment = prop.asKindOrThrow(SyntaxKind.PropertyAssignment);
      const initializer = propAssignment.getInitializer();
      if (initializer && initializer.isKind(SyntaxKind.ObjectLiteralExpression)) {
        nestSpreadProperties(
          initializer.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)
        );
      } else if (initializer && initializer.isKind(SyntaxKind.ArrayLiteralExpression)) {
        nestSpreadElements(
          initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)
        );
      }
    }
  }
}
function nestSpreadElements(arr) {
  const elements = arr.getElements();
  for (let j = 0; j < elements.length; j++) {
    const element = elements[j];
    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {
      nestSpreadProperties(
        element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)
      );
    } else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {
      nestSpreadElements(
        element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)
      );
    } else if (element.isKind(SyntaxKind.SpreadElement)) {
      const spreadText = element.getText();
      arr.removeElement(j);
      arr.insertElement(j, `"${spreadText}"`);
    }
  }
}
function unnestSpreadProperties(obj) {
  const properties = obj.getProperties();
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.isKind(SyntaxKind.PropertyAssignment)) {
      const propAssignment = prop;
      const initializer = propAssignment.getInitializer();
      if (initializer && initializer.isKind(SyntaxKind.StringLiteral)) {
        const value = initializer.asKindOrThrow(SyntaxKind.StringLiteral).getLiteralValue();
        if (value.startsWith("...")) {
          obj.insertSpreadAssignment(i, { expression: value.slice(3) });
          propAssignment.remove();
        }
      } else if (initializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {
        unnestSpreadProperties(initializer);
      } else if (initializer && initializer.isKind(SyntaxKind.ArrayLiteralExpression)) {
        unnsetSpreadElements(
          initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)
        );
      }
    }
  }
}
function unnsetSpreadElements(arr) {
  const elements = arr.getElements();
  for (let j = 0; j < elements.length; j++) {
    const element = elements[j];
    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {
      unnestSpreadProperties(
        element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)
      );
    } else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {
      unnsetSpreadElements(
        element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)
      );
    } else if (element.isKind(SyntaxKind.StringLiteral)) {
      const spreadText = element.getText();
      const spreadTest = /^['"](\.\.\..*)['"]$/g;
      if (spreadTest.test(spreadText)) {
        arr.removeElement(j);
        arr.insertElement(j, spreadText.replace(spreadTest, "$1"));
      }
    }
  }
}
async function parseObjectLiteral(objectLiteralString) {
  const sourceFile = await _createSourceFile(
    `const theme = ${objectLiteralString}`,
    null
  );
  const statement = sourceFile.getStatements()[0];
  if (statement?.getKind() === SyntaxKind.VariableStatement) {
    const declaration = statement.getDeclarationList()?.getDeclarations()[0];
    const initializer = declaration.getInitializer();
    if (initializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {
      return await parseObjectLiteralExpression(initializer);
    }
  }
  throw new Error("Invalid input: not an object literal");
}
function parseObjectLiteralExpression(node) {
  const result = {};
  for (const property of node.getProperties()) {
    if (property.isKind(SyntaxKind.PropertyAssignment)) {
      const name = property.getName().replace(/'/g, "");
      if (property.getInitializer()?.isKind(SyntaxKind.ObjectLiteralExpression)) {
        result[name] = parseObjectLiteralExpression(
          property.getInitializer()
        );
      } else if (property.getInitializer()?.isKind(SyntaxKind.ArrayLiteralExpression)) {
        result[name] = parseArrayLiteralExpression(
          property.getInitializer()
        );
      } else {
        result[name] = parseValue(property.getInitializer());
      }
    }
  }
  return result;
}
function parseArrayLiteralExpression(node) {
  const result = [];
  for (const element of node.getElements()) {
    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {
      result.push(
        parseObjectLiteralExpression(
          element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)
        )
      );
    } else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {
      result.push(
        parseArrayLiteralExpression(
          element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)
        )
      );
    } else {
      result.push(parseValue(element));
    }
  }
  return result;
}
function parseValue(node) {
  switch (node.getKind()) {
    case SyntaxKind.StringLiteral:
      return node.getText();
    case SyntaxKind.NumericLiteral:
      return Number(node.getText());
    case SyntaxKind.TrueKeyword:
      return true;
    case SyntaxKind.FalseKeyword:
      return false;
    case SyntaxKind.NullKeyword:
      return null;
    case SyntaxKind.ArrayLiteralExpression:
      return node.getElements().map(parseValue);
    case SyntaxKind.ObjectLiteralExpression:
      return parseObjectLiteralExpression(node);
    default:
      return node.getText();
  }
}
function buildTailwindThemeColorsFromCssVars(cssVars) {
  const result = {};
  for (const key of Object.keys(cssVars)) {
    const parts = key.split("-");
    const colorName = parts[0];
    const subType = parts.slice(1).join("-");
    if (subType === "") {
      if (typeof result[colorName] === "object") {
        result[colorName].DEFAULT = `hsl(var(--${key}))`;
      } else {
        result[colorName] = `hsl(var(--${key}))`;
      }
    } else {
      if (typeof result[colorName] !== "object") {
        result[colorName] = { DEFAULT: `hsl(var(--${colorName}))` };
      }
      result[colorName][subType] = `hsl(var(--${key}))`;
    }
  }
  for (const [colorName, value] of Object.entries(result)) {
    if (typeof value === "object" && value.DEFAULT === `hsl(var(--${colorName}))` && !(colorName in cssVars)) {
      delete value.DEFAULT;
    }
  }
  return result;
}

// src/utils/registry/index.ts
import deepmerge2 from "deepmerge";
import { ofetch } from "ofetch";
import path2 from "pathe";
import { ProxyAgent } from "undici";
import { z as z2 } from "zod";
var REGISTRY_URL = process.env.REGISTRY_URL ?? "https://next.shadcn-vue.com/r";
var agent = process.env.https_proxy ? new ProxyAgent(process.env.https_proxy) : void 0;
async function getRegistryIndex() {
  try {
    const [result] = await fetchRegistry(["index.json"]);
    return registryIndexSchema.parse(result);
  } catch (error) {
    logger.error("\n");
    handleError(error);
  }
}
async function getRegistryStyles() {
  try {
    const [result] = await fetchRegistry(["styles/index.json"]);
    return stylesSchema.parse(result);
  } catch (error) {
    logger.error("\n");
    handleError(error);
    return [];
  }
}
async function getRegistryIcons() {
  try {
    const [result] = await fetchRegistry(["icons/index.json"]);
    return iconsSchema.parse(result);
  } catch (error) {
    handleError(error);
    return {};
  }
}
async function getRegistryBaseColors() {
  return [
    {
      name: "neutral",
      label: "Neutral"
    },
    {
      name: "gray",
      label: "Gray"
    },
    {
      name: "zinc",
      label: "Zinc"
    },
    {
      name: "stone",
      label: "Stone"
    },
    {
      name: "slate",
      label: "Slate"
    }
  ];
}
async function getRegistryBaseColor(baseColor) {
  try {
    const [result] = await fetchRegistry([`colors/${baseColor}.json`]);
    return registryBaseColorSchema.parse(result);
  } catch (error) {
    handleError(error);
  }
}
async function fetchTree(style, tree) {
  try {
    const paths = tree.map((item) => `styles/${style}/${item.name}.json`);
    const result = await fetchRegistry(paths);
    return registryIndexSchema.parse(result);
  } catch (error) {
    handleError(error);
  }
}
async function getItemTargetPath(config, item, override) {
  if (override) {
    return override;
  }
  if (item.type === "registry:ui") {
    return config.resolvedPaths.ui ?? config.resolvedPaths.components;
  }
  const [parent, type] = item.type?.split(":") ?? [];
  if (!(parent in config.resolvedPaths)) {
    return null;
  }
  return path2.join(
    config.resolvedPaths[parent],
    type
  );
}
async function fetchRegistry(paths) {
  try {
    const results = await Promise.all(
      paths.map(async (path16) => {
        const url = getRegistryUrl(path16);
        const response = await ofetch(url, { dispatcher: agent, parseResponse: JSON.parse }).catch((error) => {
          throw new Error(error.data);
        });
        return response;
      })
    );
    return results;
  } catch (error) {
    logger.error("\n");
    handleError(error);
    return [];
  }
}
function getRegistryItemFileTargetPath(file, config, override) {
  if (override) {
    return override;
  }
  if (file.type === "registry:ui") {
    const folder = file.path.split("/")[1];
    return path2.join(config.resolvedPaths.ui, folder);
  }
  if (file.type === "registry:lib") {
    return config.resolvedPaths.lib;
  }
  if (file.type === "registry:block" || file.type === "registry:component") {
    return config.resolvedPaths.components;
  }
  if (file.type === "registry:hook") {
    return config.resolvedPaths.composables;
  }
  if (file.type === "registry:page") {
    return config.resolvedPaths.components;
  }
  return config.resolvedPaths.components;
}
async function registryResolveItemsTree(names, config) {
  try {
    const index = await getRegistryIndex();
    if (!index) {
      return null;
    }
    if (names.includes("index")) {
      names.unshift("index");
    }
    const registryDependencies = /* @__PURE__ */ new Set();
    for (const name of names) {
      const itemRegistryDependencies = await resolveRegistryDependencies(
        name,
        config
      );
      itemRegistryDependencies.forEach((dep) => registryDependencies.add(dep));
    }
    const uniqueRegistryDependencies = Array.from(registryDependencies);
    const result = await fetchRegistry(uniqueRegistryDependencies);
    const payload = z2.array(registryItemSchema).parse(result);
    if (!payload) {
      return null;
    }
    if (names.includes("index")) {
      if (config.tailwind.baseColor) {
        const theme = await registryGetTheme(config.tailwind.baseColor, config);
        if (theme) {
          payload.unshift(theme);
        }
      }
    }
    let tailwind = {};
    payload.forEach((item) => {
      tailwind = deepmerge2(tailwind, item.tailwind ?? {});
    });
    let cssVars = {};
    payload.forEach((item) => {
      cssVars = deepmerge2(cssVars, item.cssVars ?? {});
    });
    let docs = "";
    payload.forEach((item) => {
      if (item.docs) {
        docs += `${item.docs}
`;
      }
    });
    return registryResolvedItemsTreeSchema.parse({
      dependencies: Array.from(new Set(payload.flatMap((item) => item.dependencies ?? []))),
      devDependencies: Array.from(new Set(payload.flatMap((item) => item.devDependencies ?? []))),
      files: deepmerge2.all(payload.map((item) => item.files ?? [])),
      tailwind,
      cssVars,
      docs
    });
  } catch (error) {
    handleError(error);
    return null;
  }
}
async function resolveRegistryDependencies(url, config) {
  const visited = /* @__PURE__ */ new Set();
  const payload = [];
  async function resolveDependencies(itemUrl) {
    const url2 = getRegistryUrl(
      isUrl(itemUrl) ? itemUrl : `styles/${config.style}/${itemUrl}.json`
    );
    if (visited.has(url2)) {
      return;
    }
    visited.add(url2);
    try {
      const [result] = await fetchRegistry([url2]);
      const item = registryItemSchema.parse(result);
      payload.push(url2);
      if (item.registryDependencies) {
        for (const dependency of item.registryDependencies) {
          await resolveDependencies(dependency);
        }
      }
    } catch (error) {
      console.error(
        `Error fetching or parsing registry item at ${itemUrl}:`,
        error
      );
    }
  }
  await resolveDependencies(url);
  return Array.from(new Set(payload));
}
async function registryGetTheme(name, config) {
  const baseColor = await getRegistryBaseColor(name);
  if (!baseColor) {
    return null;
  }
  const theme = {
    name,
    type: "registry:theme",
    tailwind: {
      config: {
        theme: {
          extend: {
            borderRadius: {
              lg: "var(--radius)",
              md: "calc(var(--radius) - 2px)",
              sm: "calc(var(--radius) - 4px)"
            },
            colors: {}
          }
        }
      }
    },
    cssVars: {
      light: {
        radius: "0.5rem"
      },
      dark: {}
    }
  };
  if (config.tailwind.cssVariables) {
    theme.tailwind.config.theme.extend.colors = {
      ...theme.tailwind.config.theme.extend.colors,
      ...buildTailwindThemeColorsFromCssVars(baseColor.cssVars.dark)
    };
    theme.cssVars = {
      light: {
        ...baseColor.cssVars.light,
        ...theme.cssVars.light
      },
      dark: {
        ...baseColor.cssVars.dark,
        ...theme.cssVars.dark
      }
    };
  }
  return theme;
}
function getRegistryUrl(path16) {
  if (isUrl(path16)) {
    const url = new URL(path16);
    if (url.pathname.match(/\/chat\/b\//) && !url.pathname.endsWith("/json")) {
      url.pathname = `${url.pathname}/json`;
    }
    return url.toString();
  }
  return `${REGISTRY_URL}/${path16}`;
}
function isUrl(path16) {
  try {
    new URL(path16);
    return true;
  } catch (error) {
    return false;
  }
}

// src/utils/updaters/update-css-vars.ts
import { promises as fs2 } from "node:fs";
import path3 from "pathe";
import postcss from "postcss";
import AtRule from "postcss/lib/at-rule";
async function updateCssVars(cssVars, config, options) {
  if (!cssVars || !Object.keys(cssVars).length || !config.resolvedPaths.tailwindCss) {
    return;
  }
  options = {
    cleanupDefaultNextStyles: false,
    silent: false,
    ...options
  };
  const cssFilepath = config.resolvedPaths.tailwindCss;
  const cssFilepathRelative = path3.relative(
    config.resolvedPaths.cwd,
    cssFilepath
  );
  const cssVarsSpinner = spinner(
    `Updating ${highlighter.info(cssFilepathRelative)}`,
    {
      silent: options.silent
    }
  ).start();
  const raw = await fs2.readFile(cssFilepath, "utf8");
  const output = await transformCssVars(raw, cssVars, config, {
    cleanupDefaultNextStyles: options.cleanupDefaultNextStyles
  });
  await fs2.writeFile(cssFilepath, output, "utf8");
  cssVarsSpinner.succeed();
}
async function transformCssVars(input, cssVars, config, options) {
  options = {
    cleanupDefaultNextStyles: false,
    ...options
  };
  const plugins = [updateCssVarsPlugin(cssVars)];
  if (options.cleanupDefaultNextStyles) {
    plugins.push(cleanupDefaultNextStylesPlugin());
  }
  if (config.tailwind.cssVariables) {
    plugins.push(updateBaseLayerPlugin());
  }
  const result = await postcss(plugins).process(input, {
    from: void 0
  });
  return result.css;
}
function updateBaseLayerPlugin() {
  return {
    postcssPlugin: "update-base-layer",
    Once(root) {
      const requiredRules = [
        { selector: "*", apply: "border-border" },
        { selector: "body", apply: "bg-background text-foreground" }
      ];
      let baseLayer = root.nodes.find(
        (node) => node.type === "atrule" && node.name === "layer" && node.params === "base" && requiredRules.every(
          ({ selector, apply }) => node.nodes?.some(
            (rule) => rule.type === "rule" && rule.selector === selector && rule.nodes.some(
              (applyRule) => applyRule.type === "atrule" && applyRule.name === "apply" && applyRule.params === apply
            )
          )
        )
      );
      if (!baseLayer) {
        baseLayer = postcss.atRule({
          name: "layer",
          params: "base",
          raws: { semicolon: true, between: " ", before: "\n" }
        });
        root.append(baseLayer);
      }
      requiredRules.forEach(({ selector, apply }) => {
        const existingRule = baseLayer?.nodes?.find(
          (node) => node.type === "rule" && node.selector === selector
        );
        if (!existingRule) {
          baseLayer?.append(
            postcss.rule({
              selector,
              nodes: [
                postcss.atRule({
                  name: "apply",
                  params: apply,
                  raws: { semicolon: true, before: "\n    " }
                })
              ],
              raws: { semicolon: true, between: " ", before: "\n  " }
            })
          );
        }
      });
    }
  };
}
function updateCssVarsPlugin(cssVars) {
  return {
    postcssPlugin: "update-css-vars",
    Once(root) {
      let baseLayer = root.nodes.find(
        (node) => node.type === "atrule" && node.name === "layer" && node.params === "base"
      );
      if (!(baseLayer instanceof AtRule)) {
        baseLayer = postcss.atRule({
          name: "layer",
          params: "base",
          nodes: [],
          raws: {
            semicolon: true,
            before: "\n",
            between: " "
          }
        });
        root.append(baseLayer);
      }
      if (baseLayer !== void 0) {
        Object.entries(cssVars).forEach(([key, vars]) => {
          const selector = key === "light" ? ":root" : `.${key}`;
          addOrUpdateVars(baseLayer, selector, vars);
        });
      }
    }
  };
}
function removeConflictVars(root) {
  const rootRule = root.nodes.find(
    (node) => node.type === "rule" && node.selector === ":root"
  );
  if (rootRule) {
    const propsToRemove = ["--background", "--foreground"];
    rootRule.nodes.filter(
      (node) => node.type === "decl" && propsToRemove.includes(node.prop)
    ).forEach((node) => node.remove());
    if (rootRule.nodes.length === 0) {
      rootRule.remove();
    }
  }
}
function cleanupDefaultNextStylesPlugin() {
  return {
    postcssPlugin: "cleanup-default-next-styles",
    Once(root) {
      const bodyRule = root.nodes.find(
        (node) => node.type === "rule" && node.selector === "body"
      );
      if (bodyRule) {
        bodyRule.nodes.find(
          (node) => node.type === "decl" && node.prop === "color" && ["rgb(var(--foreground-rgb))", "var(--foreground)"].includes(
            node.value
          )
        )?.remove();
        bodyRule.nodes.find((node) => {
          return node.type === "decl" && node.prop === "background" && (node.value.startsWith("linear-gradient") || node.value === "var(--background)");
        })?.remove();
        if (bodyRule.nodes.length === 0) {
          bodyRule.remove();
        }
      }
      removeConflictVars(root);
      const darkRootRule = root.nodes.find(
        (node) => node.type === "atrule" && node.params === "(prefers-color-scheme: dark)"
      );
      if (darkRootRule) {
        removeConflictVars(darkRootRule);
        if (darkRootRule.nodes.length === 0) {
          darkRootRule.remove();
        }
      }
    }
  };
}
function addOrUpdateVars(baseLayer, selector, vars) {
  let ruleNode = baseLayer.nodes?.find(
    (node) => node.type === "rule" && node.selector === selector
  );
  if (!ruleNode) {
    if (Object.keys(vars).length > 0) {
      ruleNode = postcss.rule({
        selector,
        raws: { between: " ", before: "\n  " }
      });
      baseLayer.append(ruleNode);
    }
  }
  Object.entries(vars).forEach(([key, value]) => {
    const prop = `--${key.replace(/^--/, "")}`;
    const newDecl = postcss.decl({
      prop,
      value,
      raws: { semicolon: true }
    });
    const existingDecl = ruleNode?.nodes.find(
      (node) => node.type === "decl" && node.prop === prop
    );
    existingDecl ? existingDecl.replaceWith(newDecl) : ruleNode?.append(newDecl);
  });
}

// src/utils/updaters/update-dependencies.ts
import { addDependency } from "nypm";
async function updateDependencies(dependencies, config, options) {
  dependencies = Array.from(new Set(dependencies));
  if (!dependencies?.length) {
    return;
  }
  options = {
    silent: false,
    ...options
  };
  const dependenciesSpinner = spinner(`Installing dependencies.`, { silent: options.silent })?.start();
  dependenciesSpinner?.start();
  await addDependency(dependencies, { cwd: config.resolvedPaths.cwd });
  dependenciesSpinner?.succeed();
}

// src/utils/updaters/update-files.ts
import { existsSync, promises as fs5 } from "node:fs";

// src/utils/frameworks.ts
var FRAMEWORKS = {
  vite: {
    name: "vite",
    label: "Vite",
    links: {
      installation: "https://shadcn-vue.com/docs/installation/vite",
      tailwind: "https://tailwindcss.com/docs/guides/vite"
    }
  },
  nuxt: {
    name: "nuxt",
    label: "Nuxt",
    links: {
      installation: "https://shadcn-vue.com/docs/installation/nuxt",
      tailwind: "https://tailwindcss.com/docs/guides/nuxtjs"
    }
  },
  astro: {
    name: "astro",
    label: "Astro",
    links: {
      installation: "https://shadcn-vue.com/docs/installation/astro",
      tailwind: "https://tailwindcss.com/docs/guides/astro"
    }
  },
  laravel: {
    name: "laravel",
    label: "Laravel",
    links: {
      installation: "https://shadcn-vue.com/docs/installation/laravel",
      tailwind: "https://tailwindcss.com/docs/guides/laravel"
    }
  }
};

// src/utils/resolve-import.ts
import { createPathsMatcher } from "get-tsconfig";
function resolveImport(importPath, config) {
  const matcher = createPathsMatcher(config);
  if (matcher === null) {
    return;
  }
  const paths = matcher(importPath);
  return paths[0];
}

// src/utils/get-config.ts
import { loadConfig as c12LoadConfig } from "c12";
import { getTsconfig } from "get-tsconfig";
import path4 from "pathe";
import { z as z3 } from "zod";
var TAILWIND_CSS_PATH = {
  nuxt: "assets/css/tailwind.css",
  vite: "src/assets/index.css",
  laravel: "resources/css/app.css",
  astro: "src/styles/globals.css"
};
var DEFAULT_COMPONENTS = "@/components";
var DEFAULT_UTILS = "@/lib/utils";
var DEFAULT_TAILWIND_CSS = TAILWIND_CSS_PATH.nuxt;
var DEFAULT_TAILWIND_CONFIG = "tailwind.config.js";
var rawConfigSchema = z3.object({
  $schema: z3.string().optional(),
  style: z3.string(),
  typescript: z3.boolean().default(true),
  tailwind: z3.object({
    config: z3.string(),
    css: z3.string(),
    baseColor: z3.string(),
    cssVariables: z3.boolean().default(true),
    prefix: z3.string().default("").optional()
  }),
  aliases: z3.object({
    components: z3.string(),
    composables: z3.string().optional(),
    utils: z3.string(),
    ui: z3.string().optional(),
    lib: z3.string().optional()
  }),
  iconLibrary: z3.string().optional()
}).strict();
var configSchema = rawConfigSchema.extend({
  resolvedPaths: z3.object({
    cwd: z3.string(),
    tailwindConfig: z3.string(),
    tailwindCss: z3.string(),
    utils: z3.string(),
    components: z3.string(),
    composables: z3.string(),
    lib: z3.string(),
    ui: z3.string()
  })
});
async function getConfig(cwd) {
  const config = await getRawConfig(cwd);
  if (!config) {
    return null;
  }
  if (!config.iconLibrary) {
    config.iconLibrary = config.style === "new-york" ? "radix" : "lucide";
  }
  return await resolveConfigPaths(cwd, config);
}
function getTSConfig(cwd, tsconfigName) {
  const parsedConfig = getTsconfig(path4.resolve(cwd, "package.json"), tsconfigName);
  if (parsedConfig === null) {
    throw new Error(
      `Failed to find ${highlighter.info(tsconfigName)}`
    );
  }
  return parsedConfig;
}
async function resolveConfigPaths(cwd, config) {
  const tsconfigType = config.typescript ? "tsconfig.json" : "jsconfig.json";
  const tsConfig = getTSConfig(cwd, tsconfigType);
  return configSchema.parse({
    ...config,
    resolvedPaths: {
      cwd,
      tailwindConfig: path4.resolve(cwd, config.tailwind.config),
      tailwindCss: path4.resolve(cwd, config.tailwind.css),
      utils: await resolveImport(config.aliases.utils, tsConfig),
      components: await resolveImport(config.aliases.components, tsConfig),
      ui: config.aliases.ui ? await resolveImport(config.aliases.ui, tsConfig) : path4.resolve(
        await resolveImport(config.aliases.components, tsConfig) ?? cwd,
        "ui"
      ),
      // TODO: Make this configurable.
      // For now, we assume the lib and hooks directories are one level up from the components directory.
      lib: config.aliases.lib ? await resolveImport(config.aliases.lib, tsConfig) : path4.resolve(
        await resolveImport(config.aliases.utils, tsConfig) ?? cwd,
        ".."
      ),
      composables: config.aliases.composables ? await resolveImport(config.aliases.composables, tsConfig) : path4.resolve(
        await resolveImport(config.aliases.components, tsConfig) ?? cwd,
        "..",
        "composables"
      )
    }
  });
}
async function getRawConfig(cwd) {
  try {
    const configResult = await c12LoadConfig({
      name: "components",
      configFile: "components",
      cwd
    });
    if (!configResult.config || Object.keys(configResult.config).length === 0)
      return null;
    return rawConfigSchema.parse(configResult.config);
  } catch (error) {
    throw new Error(`Invalid configuration found in ${cwd}/components.json.`);
  }
}

// src/utils/get-package-info.ts
import fs3 from "fs-extra";
import path5 from "pathe";
function getPackageInfo(cwd = "", shouldThrow = true) {
  const packageJsonPath = path5.join(cwd, "package.json");
  return fs3.readJSONSync(packageJsonPath, {
    throws: shouldThrow
  });
}

// src/utils/get-project-info.ts
import fs4 from "fs-extra";
import { parseTsconfig } from "get-tsconfig";
import path6 from "pathe";
import { glob } from "tinyglobby";
import { z as z4 } from "zod";
var PROJECT_SHARED_IGNORE = [
  "**/node_modules/**",
  ".nuxt",
  "public",
  "dist",
  "build"
];
var TS_CONFIG_SCHEMA = z4.object({
  compilerOptions: z4.object({
    paths: z4.record(z4.string().or(z4.array(z4.string())))
  })
});
async function getProjectInfo(cwd) {
  const [
    configFiles,
    typescript,
    tailwindConfigFile,
    tailwindCssFile,
    aliasPrefix,
    packageJson
  ] = await Promise.all([
    glob("**/{nuxt,vite,astro}.config.*|composer.json", {
      cwd,
      deep: 3,
      ignore: PROJECT_SHARED_IGNORE
    }),
    isTypeScriptProject(cwd),
    getTailwindConfigFile(cwd),
    getTailwindCssFile(cwd),
    getTsConfigAliasPrefix(cwd),
    getPackageInfo(cwd, false)
  ]);
  const type = {
    framework: FRAMEWORKS.vite,
    // TODO: Maybe add a manual installation
    typescript,
    tailwindConfigFile,
    tailwindCssFile,
    aliasPrefix
  };
  if (configFiles.find((file) => file.startsWith("nuxt.config."))?.length) {
    type.framework = FRAMEWORKS.nuxt;
    return type;
  }
  if (configFiles.find((file) => file.startsWith("astro.config."))?.length) {
    type.framework = FRAMEWORKS.astro;
    return type;
  }
  if (configFiles.find((file) => file.startsWith("composer.json"))?.length) {
    type.framework = FRAMEWORKS.laravel;
    return type;
  }
  if (configFiles.find((file) => file.startsWith("vite.config."))?.length) {
    type.framework = FRAMEWORKS.vite;
    return type;
  }
  return type;
}
async function getTailwindCssFile(cwd) {
  const files = await glob(["**/*.css", "**/*.scss"], {
    cwd,
    deep: 5,
    ignore: PROJECT_SHARED_IGNORE
  });
  if (!files.length) {
    return null;
  }
  for (const file of files) {
    const contents = await fs4.readFile(path6.resolve(cwd, file), "utf8");
    if (contents.includes("@tailwind base")) {
      return file;
    }
  }
  return null;
}
async function getTailwindConfigFile(cwd) {
  const files = await glob("tailwind.config.*", {
    cwd,
    deep: 3,
    ignore: PROJECT_SHARED_IGNORE
  });
  if (!files.length) {
    return null;
  }
  return files[0];
}
async function getTsConfigAliasPrefix(cwd) {
  const isTypescript = await isTypeScriptProject(cwd);
  const tsconfigType = isTypescript ? "tsconfig.json" : "jsconfig.json";
  const tsConfig = getTSConfig(cwd, tsconfigType);
  const parsedTsConfig = parseTsconfig(tsConfig.path);
  const aliasPaths = parsedTsConfig.compilerOptions?.paths ?? {};
  for (const [alias, paths] of Object.entries(aliasPaths)) {
    if (paths.includes("./*") || paths.includes("./src/*") || paths.includes("./app/*") || paths.includes("./resources/js/*")) {
      const cleanAlias = alias.replace(/\/\*$/, "") ?? null;
      return cleanAlias === "#build" ? "@" : cleanAlias;
    }
  }
  return Object.keys(aliasPaths)?.[0]?.replace(/\/\*$/, "") ?? null;
}
async function isTypeScriptProject(cwd) {
  const files = await glob("tsconfig.*", {
    cwd,
    deep: 1,
    ignore: PROJECT_SHARED_IGNORE
  });
  return files.length > 0;
}
async function getProjectConfig(cwd, defaultProjectInfo = null) {
  const [existingConfig, projectInfo] = await Promise.all([
    getConfig(cwd),
    !defaultProjectInfo ? getProjectInfo(cwd) : Promise.resolve(defaultProjectInfo)
  ]);
  if (existingConfig) {
    return existingConfig;
  }
  if (!projectInfo || !projectInfo.tailwindConfigFile || !projectInfo.tailwindCssFile) {
    return null;
  }
  const config = {
    $schema: "https://shadcn-vue.com/schema.json",
    typescript: true,
    style: "new-york",
    tailwind: {
      config: projectInfo.tailwindConfigFile,
      baseColor: "zinc",
      css: projectInfo.tailwindCssFile,
      cssVariables: true,
      prefix: ""
    },
    iconLibrary: "lucide",
    aliases: {
      components: `${projectInfo.aliasPrefix}/components`,
      ui: `${projectInfo.aliasPrefix}/components/ui`,
      composables: `${projectInfo.aliasPrefix}/composables`,
      lib: `${projectInfo.aliasPrefix}/lib`,
      utils: `${projectInfo.aliasPrefix}/lib/utils`
    }
  };
  return await resolveConfigPaths(cwd, config);
}

// src/utils/transformers/transform-css-vars.ts
function transformCssVars2(opts) {
  return {
    type: "codemod",
    name: "add prefix to tailwind classes",
    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {
      let transformCount = 0;
      const { baseColor, config } = opts;
      if (config.tailwind?.cssVariables || !baseColor?.inlineColors)
        return transformCount;
      for (const scriptAST of scriptASTs) {
        traverseScriptAST(scriptAST, {
          visitLiteral(path16) {
            if (path16.parent.value.type !== "ImportDeclaration" && typeof path16.node.value === "string") {
              path16.node.value = applyColorMapping(path16.node.value.replace(/"/g, ""), baseColor.inlineColors);
              transformCount++;
            }
            return this.traverse(path16);
          }
        });
      }
      if (sfcAST) {
        traverseTemplateAST(sfcAST, {
          enterNode(node) {
            if (node.type === "Literal" && typeof node.value === "string") {
              if (!["BinaryExpression", "Property"].includes(node.parent?.type ?? "")) {
                node.value = applyColorMapping(node.value.replace(/"/g, ""), baseColor.inlineColors);
                transformCount++;
              }
            } else if (node.type === "VLiteral" && typeof node.value === "string") {
              if (node.parent.key.name === "class") {
                node.value = `"${applyColorMapping(node.value.replace(/"/g, ""), baseColor.inlineColors)}"`;
                transformCount++;
              }
            }
          },
          leaveNode() {
          }
        });
      }
      return transformCount;
    }
  };
}
function splitClassName(className) {
  if (!className.includes("/") && !className.includes(":"))
    return [null, className, null];
  const parts = [];
  const [rest, alpha] = className.split("/");
  if (!rest.includes(":"))
    return [null, rest, alpha];
  const split = rest.split(":");
  const name = split.pop();
  const variant = split.join(":");
  parts.push(variant ?? null, name ?? null, alpha ?? null);
  return parts;
}
var PREFIXES = ["bg-", "text-", "border-", "ring-offset-", "ring-"];
function applyColorMapping(input, mapping) {
  if (input.includes(" border "))
    input = input.replace(" border ", " border border-border ");
  const classNames = input.split(" ");
  const lightMode = /* @__PURE__ */ new Set();
  const darkMode = /* @__PURE__ */ new Set();
  for (const className of classNames) {
    const [variant, value, modifier] = splitClassName(className);
    const prefix = PREFIXES.find((prefix2) => value?.startsWith(prefix2));
    if (!prefix) {
      if (!lightMode.has(className))
        lightMode.add(className);
      continue;
    }
    const needle = value?.replace(prefix, "");
    if (needle && needle in mapping.light) {
      lightMode.add(
        [variant, `${prefix}${mapping.light[needle]}`].filter(Boolean).join(":") + (modifier ? `/${modifier}` : "")
      );
      darkMode.add(
        ["dark", variant, `${prefix}${mapping.dark[needle]}`].filter(Boolean).join(":") + (modifier ? `/${modifier}` : "")
      );
      continue;
    }
    if (!lightMode.has(className))
      lightMode.add(className);
  }
  return [...Array.from(lightMode), ...Array.from(darkMode)].join(" ").trim();
}

// src/utils/transformers/transform-import.ts
function transformImport(opts) {
  return {
    type: "codemod",
    name: "modify import based on user config",
    transform({ scriptASTs, utils: { traverseScriptAST } }) {
      const transformCount = 0;
      const { config } = opts;
      for (const scriptAST of scriptASTs) {
        traverseScriptAST(scriptAST, {
          visitImportDeclaration(path16) {
            if (typeof path16.node.source.value === "string") {
              const sourcePath = path16.node.source.value;
              if (sourcePath.startsWith("@/registry/")) {
                if (config.aliases.ui) {
                  path16.node.source.value = sourcePath.replace(/^@\/registry\/[^/]+\/ui/, config.aliases.ui);
                } else {
                  path16.node.source.value = sourcePath.replace(/^@\/registry\/[^/]+/, config.aliases.components);
                }
              }
              if (sourcePath === "@/lib/utils") {
                const namedImports = path16.node.specifiers?.map((node) => node.local?.name ?? "") ?? [];
                const cnImport = namedImports.find((i) => i === "cn");
                if (cnImport) {
                  path16.node.source.value = sourcePath.replace(/^@\/lib\/utils/, config.aliases.utils);
                }
              }
            }
            return this.traverse(path16);
          }
        });
      }
      return transformCount;
    }
  };
}

// src/utils/transformers/transform-sfc.ts
import { transform } from "@unovue/detypes";
async function transformSFC(opts) {
  if (opts.config?.typescript)
    return opts.raw;
  return await transformByDetype(opts.raw, opts.filename).then((res) => res);
}
async function transformByDetype(content, filename) {
  return await transform(content, filename, {
    removeTsComments: true,
    prettierOptions: {
      proseWrap: "never"
    }
  });
}

// src/utils/transformers/transform-tw-prefix.ts
function transformTwPrefix(opts) {
  return {
    type: "codemod",
    name: "add prefix to tailwind classes",
    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST, astHelpers } }) {
      let transformCount = 0;
      const { config } = opts;
      const CLASS_IDENTIFIER = ["class", "classes"];
      if (!config.tailwind?.prefix)
        return transformCount;
      for (const scriptAST of scriptASTs) {
        traverseScriptAST(scriptAST, {
          visitCallExpression(path16) {
            if (path16.node.callee.type === "Identifier" && path16.node.callee.name === "cva") {
              const nodes = path16.node.arguments;
              nodes.forEach((node) => {
                if (node.type === "Literal" && typeof node.value === "string") {
                  node.value = applyPrefix(node.value, config.tailwind.prefix);
                  transformCount++;
                } else if (node.type === "ObjectExpression") {
                  node.properties.forEach((node2) => {
                    if (node2.type === "Property" && node2.key.type === "Identifier" && node2.key.name === "variants") {
                      const nodes2 = astHelpers.findAll(node2, { type: "Literal" });
                      nodes2.forEach((node3) => {
                        if (typeof node3.value === "string") {
                          node3.value = applyPrefix(node3.value, config.tailwind.prefix);
                          transformCount++;
                        }
                      });
                    }
                  });
                }
              });
            }
            return this.traverse(path16);
          }
        });
      }
      if (sfcAST) {
        traverseTemplateAST(sfcAST, {
          enterNode(node) {
            if (node.type === "VAttribute" && node.key.type === "VDirectiveKey") {
              if (node.key.argument?.type === "VIdentifier") {
                if (CLASS_IDENTIFIER.includes(node.key.argument.name)) {
                  const nodes = astHelpers.findAll(node, { type: "Literal" });
                  nodes.forEach((node2) => {
                    if (!["BinaryExpression", "Property"].includes(node2.parent?.type ?? "") && typeof node2.value === "string") {
                      node2.value = applyPrefix(node2.value, config.tailwind.prefix);
                      transformCount++;
                    }
                  });
                }
              }
            } else if (node.type === "VLiteral" && typeof node.value === "string") {
              if (CLASS_IDENTIFIER.includes(node.parent.key.name)) {
                node.value = `"${applyPrefix(node.value.replace(/"/g, ""), config.tailwind.prefix)}"`;
                transformCount++;
              }
            }
          },
          leaveNode() {
          }
        });
      }
      return transformCount;
    }
  };
}
function applyPrefix(input, prefix = "") {
  const classNames = input.split(" ");
  const prefixed = [];
  for (const className of classNames) {
    const [variant, value, modifier] = splitClassName(className);
    if (variant) {
      modifier ? prefixed.push(`${variant}:${prefix}${value}/${modifier}`) : prefixed.push(`${variant}:${prefix}${value}`);
    } else {
      modifier ? prefixed.push(`${prefix}${value}/${modifier}`) : prefixed.push(`${prefix}${value}`);
    }
  }
  return prefixed.join(" ");
}

// src/utils/transformers/index.ts
import { transform as metaTransform } from "vue-metamorph";

// src/utils/icon-libraries.ts
var ICON_LIBRARIES = {
  lucide: {
    name: "lucide-vue-next",
    package: "lucide-vue-next",
    import: "lucide-vue-next"
  },
  radix: {
    name: "@radix-icons/vue",
    package: "@radix-icons/vue",
    import: "@radix-icons/vue"
  }
};

// src/utils/transformers/transform-icons.ts
var SOURCE_LIBRARY = "lucide";
function transformIcons(opts, registryIcons) {
  return {
    type: "codemod",
    name: "modify import of icon library on user config",
    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {
      let transformCount = 0;
      const { config } = opts;
      if (!config.iconLibrary || !(config.iconLibrary in ICON_LIBRARIES)) {
        return transformCount;
      }
      const sourceLibrary = SOURCE_LIBRARY;
      const targetLibrary = config.iconLibrary;
      if (sourceLibrary === targetLibrary) {
        return transformCount;
      }
      const targetedIconsMap = /* @__PURE__ */ new Map();
      for (const scriptAST of scriptASTs) {
        traverseScriptAST(scriptAST, {
          visitImportDeclaration(path16) {
            if (![ICON_LIBRARIES.radix.import, ICON_LIBRARIES.lucide.import].includes(`${path16.node.source.value}`))
              return this.traverse(path16);
            for (const specifier of path16.node.specifiers ?? []) {
              if (specifier.type === "ImportSpecifier") {
                const iconName = specifier.imported.name;
                const targetedIcon = registryIcons[iconName]?.[targetLibrary];
                if (!targetedIcon || targetedIconsMap.has(targetedIcon)) {
                  continue;
                }
                targetedIconsMap.set(iconName, targetedIcon);
                specifier.imported.name = targetedIcon;
              }
            }
            if (targetedIconsMap.size > 0)
              path16.node.source.value = ICON_LIBRARIES[targetLibrary].import;
            return this.traverse(path16);
          }
        });
        if (sfcAST) {
          traverseTemplateAST(sfcAST, {
            enterNode(node) {
              if (node.type === "VElement" && targetedIconsMap.has(node.rawName)) {
                node.rawName = targetedIconsMap.get(node.rawName) ?? "";
                transformCount++;
              }
            }
          });
        }
      }
      return transformCount;
    }
  };
}

// src/utils/transformers/index.ts
async function transform2(opts) {
  const source = await transformSFC(opts);
  const registryIcons = await getRegistryIcons();
  return metaTransform(source, opts.filename, [
    transformImport(opts),
    transformCssVars2(opts),
    transformTwPrefix(opts),
    transformIcons(opts, registryIcons)
  ]).code;
}

// src/utils/updaters/update-files.ts
import path7, { basename, dirname } from "pathe";
import prompts from "prompts";
function resolveTargetDir(projectInfo, config, target) {
  if (target.startsWith("~/")) {
    return path7.join(config.resolvedPaths.cwd, target.replace("~/", ""));
  }
  return path7.join(config.resolvedPaths.cwd, target);
}
async function updateFiles(files, config, options) {
  if (!files?.length) {
    return;
  }
  options = {
    overwrite: false,
    force: false,
    silent: false,
    ...options
  };
  const filesCreatedSpinner = spinner(`Updating files.`, {
    silent: options.silent
  })?.start();
  const [projectInfo, baseColor] = await Promise.all([
    getProjectInfo(config.resolvedPaths.cwd),
    getRegistryBaseColor(config.tailwind.baseColor)
  ]);
  const filesCreated = [];
  const filesUpdated = [];
  const folderSkipped = /* @__PURE__ */ new Map();
  const filesSkipped = [];
  for (const file of files) {
    if (!file.content) {
      continue;
    }
    let targetDir = getRegistryItemFileTargetPath(file, config);
    const fileName = basename(file.path);
    let filePath = path7.join(targetDir, fileName);
    if (file.target) {
      filePath = resolveTargetDir(projectInfo, config, file.target);
      targetDir = path7.dirname(filePath);
    }
    if (!config.typescript) {
      filePath = filePath.replace(/\.ts?$/, (match) => ".js");
    }
    const existingFile = existsSync(filePath);
    if (file.type === "registry:ui") {
      const folderName = basename(dirname(filePath));
      const existingFolder = existsSync(dirname(filePath));
      if (!existingFolder) {
        folderSkipped.set(folderName, false);
      }
      if (!folderSkipped.has(folderName)) {
        filesCreatedSpinner.stop();
        const { overwrite } = await prompts({
          type: "confirm",
          name: "overwrite",
          message: `The folder ${highlighter.info(folderName)} already exists. Would you like to overwrite?`,
          initial: false
        });
        folderSkipped.set(folderName, !overwrite);
        filesCreatedSpinner?.start();
      }
      if (folderSkipped.get(folderName) === true) {
        filesSkipped.push(path7.relative(config.resolvedPaths.cwd, filePath));
        continue;
      }
    } else {
      if (existingFile && !options.overwrite) {
        filesCreatedSpinner.stop();
        const { overwrite } = await prompts({
          type: "confirm",
          name: "overwrite",
          message: `The file ${highlighter.info(
            fileName
          )} already exists. Would you like to overwrite?`,
          initial: false
        });
        if (!overwrite) {
          filesSkipped.push(path7.relative(config.resolvedPaths.cwd, filePath));
          continue;
        }
        filesCreatedSpinner?.start();
      }
    }
    if (!existsSync(targetDir)) {
      await fs5.mkdir(targetDir, { recursive: true });
    }
    const content = await transform2({
      filename: file.path,
      raw: file.content,
      config,
      baseColor
    });
    await fs5.writeFile(filePath, content, "utf-8");
    existingFile ? filesUpdated.push(path7.relative(config.resolvedPaths.cwd, filePath)) : filesCreated.push(path7.relative(config.resolvedPaths.cwd, filePath));
  }
  const hasUpdatedFiles = filesCreated.length || filesUpdated.length;
  if (!hasUpdatedFiles && !filesSkipped.length) {
    filesCreatedSpinner?.info("No files updated.");
  }
  if (filesCreated.length) {
    filesCreatedSpinner?.succeed(
      `Created ${filesCreated.length} ${filesCreated.length === 1 ? "file" : "files"}:`
    );
    if (!options.silent) {
      for (const file of filesCreated) {
        logger.log(`  - ${file}`);
      }
    }
  } else {
    filesCreatedSpinner?.stop();
  }
  if (filesUpdated.length) {
    spinner(
      `Updated ${filesUpdated.length} ${filesUpdated.length === 1 ? "file" : "files"}:`,
      {
        silent: options.silent
      }
    )?.info();
    if (!options.silent) {
      for (const file of filesUpdated) {
        logger.log(`  - ${file}`);
      }
    }
  }
  if (filesSkipped.length) {
    spinner(
      `Skipped ${filesSkipped.length} ${filesUpdated.length === 1 ? "file" : "files"}:`,
      {
        silent: options.silent
      }
    )?.info();
    if (!options.silent) {
      for (const file of filesSkipped) {
        logger.log(`  - ${file}`);
      }
    }
  }
  if (!options.silent) {
    logger.break();
  }
}

// src/utils/add-components.ts
async function addComponents(components, config, options) {
  options = {
    overwrite: false,
    silent: false,
    isNewProject: false,
    ...options
  };
  const registrySpinner = spinner(`Checking registry.`, {
    silent: options.silent
  })?.start();
  const tree = await registryResolveItemsTree(components, config);
  if (!tree) {
    registrySpinner?.fail();
    return handleError(new Error("Failed to fetch components from registry."));
  }
  registrySpinner?.succeed();
  await updateTailwindConfig(tree.tailwind?.config, config, {
    silent: options.silent
  });
  await updateCssVars(tree.cssVars, config, {
    cleanupDefaultNextStyles: options.isNewProject,
    silent: options.silent
  });
  await updateDependencies(tree.dependencies, config, {
    silent: options.silent
  });
  await updateFiles(tree.files, config, {
    overwrite: options.overwrite,
    silent: options.silent
  });
  if (tree.docs) {
    logger.info(tree.docs);
  }
}

// src/utils/updaters/update-tailwind-content.ts
import { promises as fs6 } from "node:fs";
import path8 from "pathe";
import { SyntaxKind as SyntaxKind2 } from "ts-morph";
async function updateTailwindContent(content, config, options) {
  if (!content) {
    return;
  }
  options = {
    silent: false,
    ...options
  };
  const tailwindFileRelativePath = path8.relative(
    config.resolvedPaths.cwd,
    config.resolvedPaths.tailwindConfig
  );
  const tailwindSpinner = spinner(
    `Updating ${highlighter.info(tailwindFileRelativePath)}`,
    {
      silent: options.silent
    }
  ).start();
  const raw = await fs6.readFile(config.resolvedPaths.tailwindConfig, "utf8");
  const output = await transformTailwindContent(raw, content, config);
  await fs6.writeFile(config.resolvedPaths.tailwindConfig, output, "utf8");
  tailwindSpinner?.succeed();
}
async function transformTailwindContent(input, content, config) {
  const sourceFile = await _createSourceFile(input, config);
  const configObject = sourceFile.getDescendantsOfKind(SyntaxKind2.ObjectLiteralExpression).find(
    (node) => node.getProperties().some(
      (property) => property.isKind(SyntaxKind2.PropertyAssignment) && property.getName() === "content"
    )
  );
  if (!configObject) {
    return input;
  }
  addTailwindConfigContent(configObject, content);
  return sourceFile.getFullText();
}
async function addTailwindConfigContent(configObject, content) {
  const quoteChar = _getQuoteChar(configObject);
  const existingProperty = configObject.getProperty("content");
  if (!existingProperty) {
    const newProperty = {
      name: "content",
      initializer: `[${quoteChar}${content.join(
        `${quoteChar}, ${quoteChar}`
      )}${quoteChar}]`
    };
    configObject.addPropertyAssignment(newProperty);
    return configObject;
  }
  if (existingProperty.isKind(SyntaxKind2.PropertyAssignment)) {
    const initializer = existingProperty.getInitializer();
    if (initializer?.isKind(SyntaxKind2.ArrayLiteralExpression)) {
      for (const contentItem of content) {
        const newValue = `${quoteChar}${contentItem}${quoteChar}`;
        if (initializer.getElements().map((element) => element.getText()).includes(newValue)) {
          continue;
        }
        initializer.addElement(newValue);
      }
    }
    return configObject;
  }
  return configObject;
}

// src/commands/init.ts
import { Command } from "commander";
import path9 from "pathe";
import prompts2 from "prompts";
import { z as z5 } from "zod";
var initOptionsSchema = z5.object({
  cwd: z5.string(),
  components: z5.array(z5.string()).optional(),
  yes: z5.boolean(),
  defaults: z5.boolean(),
  force: z5.boolean(),
  silent: z5.boolean(),
  isNewProject: z5.boolean(),
  srcDir: z5.boolean().optional()
});
var init = new Command().name("init").description("initialize your project and install dependencies").argument(
  "[components...]",
  "the components to add or a url to the component."
).option("-y, --yes", "skip confirmation prompt.", true).option("-d, --defaults,", "use default configuration.", false).option("-f, --force", "force overwrite of existing configuration.", false).option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).option("-s, --silent", "mute output.", false).option(
  "--src-dir",
  "use the src directory when creating a new project.",
  false
).action(async (components, opts) => {
  try {
    const options = initOptionsSchema.parse({
      cwd: path9.resolve(opts.cwd),
      isNewProject: false,
      components,
      ...opts
    });
    await runInit(options);
    logger.log(
      `${highlighter.success(
        "Success!"
      )} Project initialization completed.
You may now add components.`
    );
    logger.break();
  } catch (error) {
    logger.break();
    handleError(error);
  }
});
async function runInit(options) {
  const projectInfo = await getProjectInfo(options.cwd);
  const projectConfig = await getProjectConfig(options.cwd, projectInfo);
  const config = projectConfig ? await promptForMinimalConfig(projectConfig, options) : await promptForConfig(await getConfig(options.cwd));
  if (!options.yes) {
    const { proceed } = await prompts2({
      type: "confirm",
      name: "proceed",
      message: `Write configuration to ${highlighter.info(
        "components.json"
      )}. Proceed?`,
      initial: true
    });
    if (!proceed) {
      process.exit(0);
    }
  }
  const componentSpinner = spinner(`Writing components.json.`).start();
  const targetPath = path9.resolve(options.cwd, "components.json");
  await fs7.writeFile(targetPath, JSON.stringify(config, null, 2), "utf8");
  componentSpinner.succeed();
  const fullConfig = await resolveConfigPaths(options.cwd, config);
  const components = ["index", ...options.components || []];
  await addComponents(components, fullConfig, {
    // Init will always overwrite files.
    overwrite: true,
    silent: options.silent,
    isNewProject: options.isNewProject || projectInfo?.framework.name === "nuxt"
  });
  if (options.isNewProject && options.srcDir) {
    await updateTailwindContent(
      ["./src/**/*.{js,ts,jsx,tsx,mdx}"],
      fullConfig,
      {
        silent: options.silent
      }
    );
  }
  return fullConfig;
}
async function promptForConfig(defaultConfig = null) {
  const [styles, baseColors] = await Promise.all([
    getRegistryStyles(),
    getRegistryBaseColors()
  ]);
  logger.info("");
  const options = await prompts2([
    {
      type: "toggle",
      name: "typescript",
      message: `Would you like to use ${highlighter.info(
        "TypeScript"
      )} (recommended)?`,
      initial: defaultConfig?.typescript ?? true,
      active: "yes",
      inactive: "no"
    },
    {
      type: "select",
      name: "style",
      message: `Which ${highlighter.info("style")} would you like to use?`,
      choices: styles.map((style) => ({
        title: style.name === "new-york" ? "New York (Recommended)" : style.label,
        value: style.name
      }))
    },
    {
      type: "select",
      name: "tailwindBaseColor",
      message: `Which color would you like to use as the ${highlighter.info(
        "base color"
      )}?`,
      choices: baseColors.map((color) => ({
        title: color.label,
        value: color.name
      }))
    },
    {
      type: "text",
      name: "tailwindCss",
      message: `Where is your ${highlighter.info("global CSS")} file?`,
      initial: defaultConfig?.tailwind.css ?? DEFAULT_TAILWIND_CSS
    },
    {
      type: "toggle",
      name: "tailwindCssVariables",
      message: `Would you like to use ${highlighter.info(
        "CSS variables"
      )} for theming?`,
      initial: defaultConfig?.tailwind.cssVariables ?? true,
      active: "yes",
      inactive: "no"
    },
    {
      type: "text",
      name: "tailwindPrefix",
      message: `Are you using a custom ${highlighter.info(
        "tailwind prefix eg. tw-"
      )}? (Leave blank if not)`,
      initial: ""
    },
    {
      type: "text",
      name: "tailwindConfig",
      message: `Where is your ${highlighter.info(
        "tailwind.config.js"
      )} located?`,
      initial: defaultConfig?.tailwind.config ?? DEFAULT_TAILWIND_CONFIG
    },
    {
      type: "text",
      name: "components",
      message: `Configure the import alias for ${highlighter.info(
        "components"
      )}:`,
      initial: defaultConfig?.aliases.components ?? DEFAULT_COMPONENTS
    },
    {
      type: "text",
      name: "utils",
      message: `Configure the import alias for ${highlighter.info("utils")}:`,
      initial: defaultConfig?.aliases.utils ?? DEFAULT_UTILS
    }
  ]);
  return rawConfigSchema.parse({
    $schema: "https://shadcn-vue.com/schema.json",
    style: options.style,
    tailwind: {
      config: options.tailwindConfig,
      css: options.tailwindCss,
      baseColor: options.tailwindBaseColor,
      cssVariables: options.tailwindCssVariables,
      prefix: options.tailwindPrefix
    },
    typescript: options.typescript,
    aliases: {
      utils: options.utils,
      components: options.components,
      // TODO: fix this.
      lib: options.components.replace(/\/components$/, "/lib"),
      composables: options.components.replace(/\/components$/, "/composables")
    }
  });
}
async function promptForMinimalConfig(defaultConfig, opts) {
  let style = defaultConfig.style;
  let baseColor = defaultConfig.tailwind.baseColor;
  let cssVariables = defaultConfig.tailwind.cssVariables;
  if (!opts.defaults) {
    const [styles, baseColors] = await Promise.all([
      getRegistryStyles(),
      getRegistryBaseColors()
    ]);
    const options = await prompts2([
      {
        type: "select",
        name: "style",
        message: `Which ${highlighter.info("style")} would you like to use?`,
        choices: styles.map((style2) => ({
          title: style2.name === "new-york" ? "New York (Recommended)" : style2.label,
          value: style2.name
        })),
        initial: 0
      },
      {
        type: "select",
        name: "tailwindBaseColor",
        message: `Which color would you like to use as the ${highlighter.info(
          "base color"
        )}?`,
        choices: baseColors.map((color) => ({
          title: color.label,
          value: color.name
        }))
      },
      {
        type: "toggle",
        name: "tailwindCssVariables",
        message: `Would you like to use ${highlighter.info(
          "CSS variables"
        )} for theming?`,
        initial: defaultConfig?.tailwind.cssVariables,
        active: "yes",
        inactive: "no"
      }
    ]);
    style = options.style;
    baseColor = options.tailwindBaseColor;
    cssVariables = options.tailwindCssVariables;
  }
  return rawConfigSchema.parse({
    $schema: defaultConfig?.$schema,
    style,
    tailwind: {
      ...defaultConfig?.tailwind,
      baseColor,
      cssVariables
    },
    aliases: defaultConfig?.aliases,
    iconLibrary: defaultConfig?.iconLibrary
  });
}

// src/utils/errors.ts
var MISSING_DIR_OR_EMPTY_PROJECT = "1";
var MISSING_CONFIG = "3";

// src/preflights/preflight-add.ts
import fs8 from "fs-extra";
import path10 from "pathe";
async function preFlightAdd(options) {
  const errors = {};
  if (!fs8.existsSync(options.cwd) || !fs8.existsSync(path10.resolve(options.cwd, "package.json"))) {
    errors[MISSING_DIR_OR_EMPTY_PROJECT] = true;
    return {
      errors,
      config: null
    };
  }
  if (!fs8.existsSync(path10.resolve(options.cwd, "components.json"))) {
    errors[MISSING_CONFIG] = true;
    return {
      errors,
      config: null
    };
  }
  try {
    const config = await getConfig(options.cwd);
    return {
      errors,
      config
    };
  } catch (error) {
    logger.break();
    logger.error(
      `An invalid ${highlighter.info(
        "components.json"
      )} file was found at ${highlighter.info(
        options.cwd
      )}.
Before you can add components, you must create a valid ${highlighter.info(
        "components.json"
      )} file by running the ${highlighter.info("init")} command.`
    );
    logger.error(
      `Learn more at ${highlighter.info(
        "https://shadcn-vue.com/docs/components-json"
      )}.`
    );
    logger.break();
    process.exit(1);
  }
}

// src/commands/add.ts
import { Command as Command2 } from "commander";
import path11 from "pathe";
import prompts3 from "prompts";
import { z as z6 } from "zod";
var addOptionsSchema = z6.object({
  components: z6.array(z6.string()).optional(),
  yes: z6.boolean(),
  overwrite: z6.boolean(),
  cwd: z6.string(),
  all: z6.boolean(),
  path: z6.string().optional(),
  silent: z6.boolean(),
  srcDir: z6.boolean().optional()
});
var add = new Command2().name("add").description("add a component to your project").argument(
  "[components...]",
  "the components to add or a url to the component."
).option("-y, --yes", "skip confirmation prompt.", false).option("-o, --overwrite", "overwrite existing files.", false).option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).option("-a, --all", "add all available components", false).option("-p, --path <path>", "the path to add the component to.").option("-s, --silent", "mute output.", false).option(
  "--src-dir",
  "use the src directory when creating a new project.",
  false
).action(async (components, opts) => {
  try {
    const options = addOptionsSchema.parse({
      components,
      cwd: path11.resolve(opts.cwd),
      ...opts
    });
    const isTheme = options.components?.some(
      (component) => component.includes("theme-")
    );
    if (!options.yes && isTheme) {
      logger.break();
      const { confirm } = await prompts3({
        type: "confirm",
        name: "confirm",
        message: highlighter.warn(
          "You are about to install a new theme. \nExisting CSS variables will be overwritten. Continue?"
        )
      });
      if (!confirm) {
        logger.break();
        logger.log("Theme installation cancelled.");
        logger.break();
        process.exit(1);
      }
    }
    if (!options.components?.length) {
      options.components = await promptForRegistryComponents(options);
    }
    let { errors, config } = await preFlightAdd(options);
    if (errors[MISSING_CONFIG]) {
      const { proceed } = await prompts3({
        type: "confirm",
        name: "proceed",
        message: `You need to create a ${highlighter.info(
          "components.json"
        )} file to add components. Proceed?`,
        initial: true
      });
      if (!proceed) {
        logger.break();
        process.exit(1);
      }
      config = await runInit({
        cwd: options.cwd,
        yes: true,
        force: true,
        defaults: false,
        skipPreflight: false,
        silent: true,
        isNewProject: false,
        srcDir: options.srcDir
      });
    }
    if (!config) {
      throw new Error(
        `Failed to read config at ${highlighter.info(options.cwd)}.`
      );
    }
    await addComponents(options.components, config, options);
  } catch (error) {
    logger.break();
    handleError(error);
  }
});
async function promptForRegistryComponents(options) {
  const registryIndex = await getRegistryIndex();
  if (!registryIndex) {
    logger.break();
    handleError(new Error("Failed to fetch registry index."));
    return [];
  }
  if (options.all) {
    return registryIndex.map((entry) => entry.name);
  }
  if (options.components?.length) {
    return options.components;
  }
  const { components } = await prompts3({
    type: "multiselect",
    name: "components",
    message: "Which components would you like to add?",
    hint: "Space to select. A to toggle all. Enter to submit.",
    instructions: false,
    choices: registryIndex.filter((entry) => entry.type === "registry:ui").map((entry) => ({
      title: entry.name,
      value: entry.name,
      selected: options.all ? true : options.components?.includes(entry.name)
    }))
  });
  if (!components?.length) {
    logger.warn("No components selected. Exiting.");
    logger.info("");
    process.exit(1);
  }
  const result = z6.array(z6.string()).safeParse(components);
  if (!result.success) {
    logger.error("");
    handleError(new Error("Something went wrong. Please try again."));
    return [];
  }
  return result.data;
}

// src/commands/diff.ts
import { existsSync as existsSync2, promises as fs9 } from "node:fs";
import { Command as Command3 } from "commander";
import { diffLines } from "diff";
import path12 from "pathe";
import { z as z7 } from "zod";
var updateOptionsSchema = z7.object({
  component: z7.string().optional(),
  yes: z7.boolean(),
  cwd: z7.string(),
  path: z7.string().optional()
});
var diff = new Command3().name("diff").description("check for updates against the registry").argument("[component]", "the component name").option("-y, --yes", "skip confirmation prompt.", false).option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).action(async (name, opts) => {
  try {
    const options = updateOptionsSchema.parse({
      component: name,
      ...opts
    });
    const cwd = path12.resolve(options.cwd);
    if (!existsSync2(cwd)) {
      logger.error(`The path ${cwd} does not exist. Please try again.`);
      process.exit(1);
    }
    const config = await getConfig(cwd);
    if (!config) {
      logger.warn(
        `Configuration is missing. Please run ${highlighter.success(
          `init`
        )} to create a components.json file.`
      );
      process.exit(1);
    }
    const registryIndex = await getRegistryIndex();
    if (!registryIndex) {
      handleError(new Error("Failed to fetch registry index."));
      process.exit(1);
    }
    if (!options.component) {
      const targetDir = config.resolvedPaths.components;
      const projectComponents = registryIndex.filter((item) => {
        for (const file of item.files ?? []) {
          const filePath = path12.resolve(
            targetDir,
            typeof file === "string" ? file : file.path
          );
          if (existsSync2(filePath)) {
            return true;
          }
        }
        return false;
      });
      const componentsWithUpdates = [];
      for (const component2 of projectComponents) {
        const changes2 = await diffComponent(component2, config);
        if (changes2.length) {
          componentsWithUpdates.push({
            name: component2.name,
            changes: changes2
          });
        }
      }
      if (!componentsWithUpdates.length) {
        logger.info("No updates found.");
        process.exit(0);
      }
      logger.info("The following components have updates available:");
      for (const component2 of componentsWithUpdates) {
        logger.info(`- ${component2.name}`);
        for (const change of component2.changes) {
          logger.info(`  - ${change.filePath}`);
        }
      }
      logger.break();
      logger.info(
        `Run ${highlighter.success(`diff <component>`)} to see the changes.`
      );
      process.exit(0);
    }
    const component = registryIndex.find(
      (item) => item.name === options.component
    );
    if (!component) {
      logger.error(
        `The component ${highlighter.success(
          options.component
        )} does not exist.`
      );
      process.exit(1);
    }
    const changes = await diffComponent(component, config);
    if (!changes.length) {
      logger.info(`No updates found for ${options.component}.`);
      process.exit(0);
    }
    for (const change of changes) {
      logger.info(`- ${change.filePath}`);
      await printDiff(change.patch);
      logger.info("");
    }
  } catch (error) {
    handleError(error);
  }
});
async function diffComponent(component, config) {
  const payload = await fetchTree(config.style, [component]);
  const baseColor = await getRegistryBaseColor(config.tailwind.baseColor);
  if (!payload) {
    return [];
  }
  const changes = [];
  for (const item of payload) {
    const targetDir = await getItemTargetPath(config, item);
    if (!targetDir) {
      continue;
    }
    for (const file of item.files ?? []) {
      const filePath = path12.resolve(
        targetDir,
        typeof file === "string" ? file : file.path
      );
      if (!existsSync2(filePath)) {
        continue;
      }
      const fileContent = await fs9.readFile(filePath, "utf8");
      if (typeof file === "string" || !file.content) {
        continue;
      }
      const registryContent = await transform2({
        filename: file.path,
        raw: file.content,
        config,
        baseColor
      });
      const patch = diffLines(registryContent, fileContent);
      if (patch.length > 1) {
        changes.push({
          filePath,
          patch
        });
      }
    }
  }
  return changes;
}
async function printDiff(diff2) {
  diff2.forEach((part) => {
    if (part) {
      if (part.added) {
        return process.stdout.write(highlighter.success(part.value));
      }
      if (part.removed) {
        return process.stdout.write(highlighter.error(part.value));
      }
      return process.stdout.write(part.value);
    }
  });
}

// src/commands/info.ts
import { Command as Command4 } from "commander";
import consola3 from "consola";
var info = new Command4().name("info").description("get information about your project").option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).action(async (opts) => {
  logger.info("> project info");
  consola3.log(await getProjectInfo(opts.cwd));
  logger.break();
  logger.info("> components.json");
  consola3.log(await getConfig(opts.cwd));
});

// src/migrations/migrate-icons.ts
import { randomBytes } from "node:crypto";
import { promises as fs10 } from "node:fs";
import { tmpdir as tmpdir2 } from "node:os";
import path13 from "pathe";
import prompts4 from "prompts";
import { glob as glob2 } from "tinyglobby";
import { Project as Project2, ScriptKind as ScriptKind2, SyntaxKind as SyntaxKind3 } from "ts-morph";
async function migrateIcons(config) {
  if (!config.resolvedPaths.ui) {
    throw new Error(
      "We could not find a valid `ui` path in your `components.json` file. Please ensure you have a valid `ui` path in your `components.json` file."
    );
  }
  const uiPath = config.resolvedPaths.ui;
  const [files, registryIcons] = await Promise.all([
    glob2("**/*.{js,ts,jsx,tsx}", {
      cwd: uiPath
    }),
    getRegistryIcons()
  ]);
  if (Object.keys(registryIcons).length === 0) {
    throw new Error("Something went wrong fetching the registry icons.");
  }
  const libraryChoices = Object.entries(ICON_LIBRARIES).map(
    ([name, iconLibrary]) => ({
      title: iconLibrary.name,
      value: name
    })
  );
  const migrateOptions = await prompts4([
    {
      type: "select",
      name: "sourceLibrary",
      message: `Which icon library would you like to ${highlighter.info(
        "migrate from"
      )}?`,
      choices: libraryChoices
    },
    {
      type: "select",
      name: "targetLibrary",
      message: `Which icon library would you like to ${highlighter.info(
        "migrate to"
      )}?`,
      choices: libraryChoices
    }
  ]);
  if (migrateOptions.sourceLibrary === migrateOptions.targetLibrary) {
    throw new Error(
      "You cannot migrate to the same icon library. Please choose a different icon library."
    );
  }
  if (!(migrateOptions.sourceLibrary in ICON_LIBRARIES && migrateOptions.targetLibrary in ICON_LIBRARIES)) {
    throw new Error("Invalid icon library. Please choose a valid icon library.");
  }
  const sourceLibrary = ICON_LIBRARIES[migrateOptions.sourceLibrary];
  const targetLibrary = ICON_LIBRARIES[migrateOptions.targetLibrary];
  const { confirm } = await prompts4({
    type: "confirm",
    name: "confirm",
    initial: true,
    message: `We will migrate ${highlighter.info(
      files.length
    )} files in ${highlighter.info(
      `./${path13.relative(config.resolvedPaths.cwd, uiPath)}`
    )} from ${highlighter.info(sourceLibrary.name)} to ${highlighter.info(
      targetLibrary.name
    )}. Continue?`
  });
  if (!confirm) {
    logger.info("Migration cancelled.");
    process.exit(0);
  }
  if (targetLibrary.package) {
    await updateDependencies([targetLibrary.package], config, {
      silent: false
    });
  }
  const migrationSpinner = spinner(`Migrating icons...`)?.start();
  await Promise.all(
    files.map(async (file) => {
      migrationSpinner.text = `Migrating ${file}...`;
      const filePath = path13.join(uiPath, file);
      const fileContent = await fs10.readFile(filePath, "utf-8");
      const content = await migrateIconsFile(
        fileContent,
        migrateOptions.sourceLibrary,
        migrateOptions.targetLibrary,
        registryIcons
      );
      await fs10.writeFile(filePath, content);
    })
  );
  migrationSpinner.succeed("Migration complete.");
}
async function migrateIconsFile(content, sourceLibrary, targetLibrary, iconsMapping) {
  const sourceLibraryImport = ICON_LIBRARIES[sourceLibrary]?.import;
  const targetLibraryImport = ICON_LIBRARIES[targetLibrary]?.import;
  const dir = await fs10.mkdtemp(path13.join(tmpdir2(), "shadcn-"));
  const project = new Project2({
    compilerOptions: {}
  });
  const tempFile = path13.join(
    dir,
    `shadcn-icons-${randomBytes(4).toString("hex")}.tsx`
  );
  const sourceFile = project.createSourceFile(tempFile, content, {
    scriptKind: ScriptKind2.TSX
  });
  const targetedIcons = [];
  for (const importDeclaration of sourceFile.getImportDeclarations() ?? []) {
    if (importDeclaration.getModuleSpecifier()?.getText() !== `"${sourceLibraryImport}"`) {
      continue;
    }
    for (const specifier of importDeclaration.getNamedImports() ?? []) {
      const iconName = specifier.getName();
      const targetedIcon = Object.values(iconsMapping).find(
        (icon) => icon[sourceLibrary] === iconName
      )?.[targetLibrary];
      if (!targetedIcon || targetedIcons.includes(targetedIcon)) {
        continue;
      }
      targetedIcons.push(targetedIcon);
      specifier.remove();
      sourceFile.getDescendantsOfKind(SyntaxKind3.JsxSelfClosingElement).filter((node) => node.getTagNameNode()?.getText() === iconName).forEach((node) => node.getTagNameNode()?.replaceWithText(targetedIcon));
    }
    if (importDeclaration.getNamedImports()?.length === 0) {
      importDeclaration.remove();
    }
  }
  if (targetedIcons.length > 0) {
    sourceFile.addImportDeclaration({
      moduleSpecifier: targetLibraryImport,
      namedImports: targetedIcons.map((icon) => ({
        name: icon
      }))
    });
  }
  return await sourceFile.getText();
}

// src/preflights/preflight-migrate.ts
import fs11 from "fs-extra";
import path14 from "pathe";
async function preFlightMigrate(options) {
  const errors = {};
  if (!fs11.existsSync(options.cwd) || !fs11.existsSync(path14.resolve(options.cwd, "package.json"))) {
    errors[MISSING_DIR_OR_EMPTY_PROJECT] = true;
    return {
      errors,
      config: null
    };
  }
  if (!fs11.existsSync(path14.resolve(options.cwd, "components.json"))) {
    errors[MISSING_CONFIG] = true;
    return {
      errors,
      config: null
    };
  }
  try {
    const config = await getConfig(options.cwd);
    return {
      errors,
      config
    };
  } catch (error) {
    logger.break();
    logger.error(
      `An invalid ${highlighter.info(
        "components.json"
      )} file was found at ${highlighter.info(
        options.cwd
      )}.
Before you can run a migration, you must create a valid ${highlighter.info(
        "components.json"
      )} file by running the ${highlighter.info("init")} command.`
    );
    logger.error(
      `Learn more at ${highlighter.info(
        "https://shadcn-vue.com/docs/components-json"
      )}.`
    );
    logger.break();
    process.exit(1);
  }
}

// src/commands/migrate.ts
import { Command as Command5 } from "commander";
import consola4 from "consola";
import path15 from "pathe";
import { z as z8 } from "zod";
var migrations = [
  {
    name: "icons",
    description: "migrate your ui components to a different icon library."
  }
];
var migrateOptionsSchema = z8.object({
  cwd: z8.string(),
  list: z8.boolean(),
  migration: z8.string().refine(
    (value) => value && migrations.some((migration) => migration.name === value),
    {
      message: "You must specify a valid migration. Run `shadcn migrate --list` to see available migrations."
    }
  ).optional()
});
var migrate = new Command5().name("migrate").description("run a migration.").argument("[migration]", "the migration to run.").option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).option("-l, --list", "list all migrations.", false).action(async (migration, opts) => {
  try {
    const options = migrateOptionsSchema.parse({
      cwd: path15.resolve(opts.cwd),
      migration,
      list: opts.list
    });
    if (options.list || !options.migration) {
      consola4.info("Available migrations:");
      for (const migration2 of migrations) {
        consola4.info(`- ${migration2.name}: ${migration2.description}`);
      }
      return;
    }
    if (!options.migration) {
      throw new Error(
        "You must specify a migration. Run `shadcn migrate --list` to see available migrations."
      );
    }
    const { errors, config } = await preFlightMigrate(options);
    if (errors[MISSING_DIR_OR_EMPTY_PROJECT] || errors[MISSING_CONFIG]) {
      throw new Error(
        "No `components.json` file found. Ensure you are at the root of your project."
      );
    }
    if (!config) {
      throw new Error(
        "Something went wrong reading your `components.json` file. Please ensure you have a valid `components.json` file."
      );
    }
    if (options.migration === "icons") {
      await migrateIcons(config);
    }
  } catch (error) {
    handleError(error);
  }
});

// src/index.ts
import { Command as Command6 } from "commander";

// package.json
var package_default = {
  name: "shadcn-vue",
  type: "module",
  version: "1.0.0",
  description: "Add components to your apps.",
  publishConfig: {
    access: "public"
  },
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/unovue/shadcn-vue.git",
    directory: "packages/cli"
  },
  keywords: [
    "components",
    "ui",
    "vue",
    "nuxt",
    "tailwind",
    "radix-ui",
    "radix-vue",
    "reka-ui",
    "shadcn",
    "shadcn-vue"
  ],
  exports: "./dist/index.js",
  bin: "./dist/index.js",
  files: [
    "dist"
  ],
  scripts: {
    dev: "tsup --watch",
    build: "tsup",
    typecheck: "tsc --noEmit",
    clean: "node ./scripts/rimraf.js",
    lint: "eslint .",
    "lint:fix": "eslint --fix .",
    "start:dev": "REGISTRY_URL=http://localhost:5173/r node dist/index.js",
    start: "node dist/index.js",
    release: "changeset version",
    "pub:beta": "pnpm build && pnpm publish --no-git-checks --access public --tag beta",
    "pub:next": "pnpm build && pnpm publish --no-git-checks --access public --tag next",
    "pub:release": "pnpm build && pnpm publish  --no-git-checks --access public",
    test: "REGISTRY_URL=http://localhost:5173/r vitest run",
    "test:update": "vitest run -u",
    "test:ui": "vitest --ui"
  },
  peerDependencies: {
    "@vitest/ui": "*",
    vitest: "*"
  },
  dependencies: {
    "@unovue/detypes": "^0.8.4",
    "@vue/compiler-sfc": "^3.5",
    c12: "^2.0.2",
    commander: "^12.1.0",
    consola: "^3.4.0",
    deepmerge: "^4.3.1",
    diff: "^7.0.0",
    "fs-extra": "^11.3.0",
    "get-tsconfig": "^4.10.0",
    "lodash-es": "^4.17.21",
    "magic-string": "^0.30.17",
    nypm: "^0.5.2",
    ofetch: "^1.4.1",
    ora: "^8.2.0",
    pathe: "^2.0.3",
    "pkg-types": "^1.3.1",
    postcss: "^8.5.2",
    prompts: "^2.4.2",
    "reka-ui": "catalog:",
    "stringify-object": "^5.0.0",
    tailwindcss: "^3.4.16",
    tinyexec: "^0.3.2",
    tinyglobby: "^0.2.10",
    "ts-morph": "^24.0.0",
    undici: "^7.3.0",
    "vue-metamorph": "3.2.0",
    zod: "^3.24.2"
  },
  devDependencies: {
    "@types/diff": "^7.0.1",
    "@types/fs-extra": "^11.0.4",
    "@types/lodash-es": "^4.17.12",
    "@types/node": "^22.13.4",
    "@types/prompts": "^2.4.9",
    "@types/stringify-object": "^4.0.5",
    tsup: "^8.3.6",
    "type-fest": "^4.34.1",
    typescript: "catalog:",
    "vite-tsconfig-paths": "^5.1.4"
  }
};

// src/index.ts
process.on("SIGINT", () => process.exit(0));
process.on("SIGTERM", () => process.exit(0));
async function main() {
  const program = new Command6().name("shadcn-vue").description("add components and dependencies to your project").version(
    package_default.version || "1.0.0",
    "-v, --version",
    "display the version number"
  );
  program.addCommand(init).addCommand(add).addCommand(diff).addCommand(migrate).addCommand(info);
  program.parse();
}
main();
//# sourceMappingURL=index.js.map